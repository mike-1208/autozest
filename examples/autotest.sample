# Usage: growlnotify [-hsvuwc] [-i ext] [-I filepath] [--image filepath]
#                    [-a appname] [-p priority] [-H host] [-P password]
#                    [--port port] [-n name] [-A method] [--progress value]
#                    [--html] [-m message] [-t] [title]
# Options:
#     -h,--help       Display this help
#     -v,--version    Display version number
#     -n,--name       Set the name of the application that sends the notification
#                     [Default: growlnotify]
#     -s,--sticky     Make the notification sticky
#     -a,--appIcon    Specify an application name (including the .app suffix)
#                     to take the icon from
#     -i,--icon       Specify a file type or extension to look up for the
#                     notification icon
#     -I,--iconpath   Specify a file whose icon will be the notification icon
#        --image      Specify an image file to be used for the notification icon
#     -m,--message    Sets the message to be used instead of using stdin
#                     Passing - as the argument means read from stdin
#     -p,--priority   Specify an int or named key (default is 0)
#     -d,--identifier Specify a notification identifier (used for coalescing)
#     -H,--host       Specify a hostname to which to send a remote notification.
#     -P,--password   Password used for remote notifications.
#     -u,--udp        Use UDP instead of DO to send a remote notification.
#        --port       Port number for UDP notifications.
#     -A,--auth       Specify digest algorithm for UDP authentication.
#                     Either MD5 [Default], SHA256 or NONE.
#     -c,--crypt      Encrypt UDP notifications.
#     -w,--wait       Wait until the notification has been dismissed.
#        --progress   Set a progress value for this notification.
# 
# Display a notification using the title given on the command-line and the
# message given in the standard input.
# 
# Priority can be one of the following named keys: Very Low, Moderate, Normal,
# High, Emergency. It can also be an int between -2 and 2.
# 
# To be compatible with gNotify the following switch is accepted:
#     -t,--title      Does nothing. Any text following will be treated as the
#                     title because that's the default argument behaviour

require "autotest"
module Autotest::Growl

  AUTOTEST_IMAGE_ROOT = "/Users/wayne/.autotest_images"

  def self.growl(title, message, image, sticky="")
    cmd = "/usr/local/bin/growlnotify -a autotest -n autotest --password smurf"
    cmd << " --image #{image}" if image
    cmd << " -m #{message.inspect}"
    cmd << " --title #{title}" unless title.empty?
    # cmd << " #{sticky}" unless sticky.empty?
    system(cmd)
  end

  def self.growl_fail(output)
    growl("FAIL", "#{output}", "#{AUTOTEST_IMAGE_ROOT}/fail.png")
  end
  #  growlnotify -a autotest -n autotest -m '"324 examples, 1 failure"'  --image ~/.autotest_images/fail.png FAIL
  #  growlnotify -a autotest -n autotest -m '"324 examples, 0 failures"'  --image ~/.autotest_images/pass.png Pass

  def self.growl_pass(output)
    growl("Pass", "#{output}", "#{AUTOTEST_IMAGE_ROOT}/pass.png")
  end

  Autotest.add_hook :ran_command do |auto_test|

    # AutoZest::Notifier.new(auto_test)
    # should take care of everything below
    # == snip ==
    results = [auto_test.results].flatten.join("\n")

    if results.include? "tests"
      output = results.slice(/(\d+)\s+tests?,\s*(\d+)\s+assertions?,\s*(\d+)\s+failures?(,\s*(\d+)\s+errors)?/)
      if output
        $~[3].to_i + $~[5].to_i > 0 ? growl_fail(output) : growl_pass(output)
      end
    else
      # rspec
      output = results.slice(/(\d+)\s+examples?,\s*(\d+)\s+failures?(,\s*(\d+)\s+not implemented)?/)
      if output
        examples,failures,pending = $1.to_i, $2.to_i, $3.to_i
        #$~[2].to_i > 0 ? growl_fail(output) : growl_pass(output)
        if failures <= 0
          growl_pass(output)
        elsif failures  < 10
          growl_fail("Cleanup aisle #{failures} (there were #{failures} failing specs).")
        elsif failures < 25
          growl_fail("Reconstruction time (there were #{failures} failing specs).")
        elsif failures < 50
          growl_fail("Things are getting pretty bad... #{failures} failing specs!!!")
        elsif failures > 50
          growl_fail("Dude, you really fucked up... #{failures} failing specs!!!")
        elsif failures > 100
          growl_fail("is the computer even on? (#{failures} failing specs!!!) ")
        else
          growl_fail("There was an error running the specs")
        end
      end
    end
  end

end
